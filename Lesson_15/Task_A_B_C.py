# A - Вашему решению будет предоставлена функция func, которая не имеет параметров и результата.
# Однако во время её исполнения может произойти одна из ошибок: ValueError, TypeError или SystemError.
# Вызовите её, обработайте ошибку и выведите её название. Если ошибка не произойдёт, выведите сообщение
# "No Exceptions".
def func():  # Не прикреплять к тестирующей системе!
    x = int('Hello, world!')

try:
    func()
    print("No Exceptions")
except ValueError:
    print("ValueError")
except TypeError:
    print("TypeError")
except SystemError:
    print("SystemError")

# B - Вашему решению будет предоставлена функция func, которая принимает два позиционных параметра
# и производит с ними некую математическую операцию.
# Предложите вызов функции, который гарантированно породит ошибку внутри функции.
# Примечание
# Если ошибка произойдёт внутри функции, то она будет перехвачена и обработана.
# Если же она произойдет в вашем коде, то программа будет завершена с ошибкой.
def func(a, b):
    return a + b

try:
    func(None, 0)
except TypeError:
    print("Ура! Ошибка!")
except Exception:
    print("Ура! Ошибка!")

# C - Вашему решению будет предоставлена функция func, которая на этот раз принимает неограниченное число
# позиционных параметров и производит с ними некую операцию приведения типа.
# Предложите вызов функции, который гарантированно породит ошибку внутри функции.
# Примечание
# Если ошибка произойдёт внутри функции, то она будет перехвачена и обработана.
# Если же она произойдет в вашем коде, то программа будет завершена с ошибкой.
def func(a, b, c):
    return ''.join(map(str, (a, b, c)))

class Except(Exception):
    def __str__(self):
        raise NameError
    def __repr__(self):
        raise NameError

try:
    func(Except(), 2, 3)
except NameError:
    print("Ура! Ошибка!")
except Exception:
    print("Ура! Ошибка!")