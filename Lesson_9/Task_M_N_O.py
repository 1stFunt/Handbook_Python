# M - Создайте программу, которая обновляет JSON файл.
# Формат ввода - Пользователь вводит имя файла.
# Затем вводятся строки вида ключ == значение.
# Формат вывода - В заданный пользователем файл следует записать обновленный JSON.
import json

filename = input()

# Открываем файл и загружаем содержимое в data
with open(filename, encoding="utf-8") as f:
    data = json.load(f)

# Считываем строки вида ключ == значение
while True:
    try:
        line = input()
        key, value = line.split(" == ")
        # Обновляем словарь
        data[key] = value
    except EOFError:
        break

# Открываем файл в режиме записи и записываем обновленный словарь
with open(filename, "w", encoding="utf-8") as f:
    json.dump(data, f, ensure_ascii=False, indent=4)

# N - Напишите программу, которая обновляет данные о пользователях, записанных в JSON файле.
# Формат ввода - Пользователь вводит два имени файла.
# В первом хранится JSON массив пользователей.
# Во втором — массив новых данных.
# Информация о каждом пользователе представляется JSON объектом, в котором обязательно присутствует поле name, 
# описывающее имя пользователя. Остальные поля являются дополнительными.
# Формат вывода - В первый файл запишите информацию о пользователях в виде JSON объекта, ключами которого выступают имена пользователей, 
# а значениями — объекты с информацией о них.
# Если какая-либо дополнительная информация о пользователе изменяется, то требуется сохранить лексикографически 
# большее значение.
import json

users = input()
updates = input()

with open(users) as f:
    old_data = json.load(f)

with open(updates) as f:
    new_data = json.load(f)

# Создаем пустой словарь
updated_data = {}

# Итерируемся по старым данным
for old_user in old_data:
    # Имени присваиваем значение ключа name в словаре
    name = old_user['name']
    # Создаем ключ в словаре, значением которого поставим пустой словарь
    updated_data[name] = {}
    # Итерируемся по новым данным
    for new_user in new_data:
        # Если значение ключа name равен имени
        if new_user['name'] == name:
            # Итерируемся по ключам и значением словаря
            for key, value in new_user.items():
                # Если ключ так же имеется и в старых данных
                if key in old_user:
                    # Сравниваем лексикографически значения ключей
                    if old_user[key] < value:
                        # В случае, если меньше - присваиваем
                        old_user[key] = value
                # Если запись не содержится в старом словаре, то просто присваиваем новую запись
                else:
                    old_user[key] = value
    # Итерируемся по ключам и значениям старого словаря
    for key, value in old_user.items():
        # Если ключ не name
        if key != 'name':
            # то присваиваем все значения вне словаря в пустой словарь, тем самым делаем только ключ, как имя
            # и значение, как все остальное. 
            updated_data[name][key] = value

with open(users, 'w') as f:
    json.dump(updated_data, f, ensure_ascii=False, indent=4)

"""
O - Напишите небольшой кусочек тестирующей системы.
Вашему решению доступен файл scoring.json, в котором содержится информация о системе проверки.
Основой системы является список групп тестов.
Каждая группа представляет собой объект с полями:
points — количество очков, которое можно получить за прохождение данной группы;
tests — список объектов с описанием конкретного теста.
Объект описывающий тест содержит поля:
input — строка входных данных теста;
pattern — строка ожидаемых в качестве ответа.
В стандартный поток ввода вашего решения передаются ответы, полученные от тестируемой программы.
Формат ввода - В стандартный поток ввода передаются строки — ответы тестируемой программы на каждый тест. 
В файле scoring.json содержится информация о тестах задачи.
Формат вывода - Одно число — количество полученных тестируемой программой баллов.
Если группа тестов не была пройдена полностью, то за данную группу ставится пропорциональный балл.
Гарантируется, что баллы за группу кратны количеству тестов в ней.    
"""
import json

with open("scoring.json") as test:
    data = json.load(test)

points = 0

for dictionary in data:
    for key, val in dictionary.items():
        if key == "tests":
            for dct in dictionary[key]:
                for k, v in dct.items():
                    if k == "pattern":
                        if input() == v:
                            points += int(dictionary["points"]) / int(len(dictionary["tests"]))
print(round(points))