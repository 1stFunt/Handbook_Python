"""
Шашки очень занимательная игра, которую достаточно легко моделировать.
Правила подразумевают наличие двух классов: игральная доска и шашка. Однако мы немного упростим себе задачу 
и вместо шашки будем манипулировать клетками, которые могут находиться в трех состояниях: пустая, белая шашка и чёрная шашка.
Разработайте два класса: Checkers и Cell.
Объекты класса Checkers при инициализации строят игральную доску со стандартным распределением клеток и должны обладать методами:
move(f, t) — перемещает шашку из позиции f в позицию t;
get_cell(p) — возвращает объект «клетка» в позиции p.
Объекты класса Cell при инициализации принимают одно из трех состояний: W — белая шашка, B — чёрная шашка, X — пустая клетка, 
а также обладают методом status() возвращающим заложенное в ней состояние.
Координаты клеток описываются строками вида PQ, где:
P — столбец игральной доски, одна из заглавных латинских букв: ABCDEFGH;
Q — строка игральной доски, одна из цифр: 12345678.
Будем считать, что пользователь всегда ходит правильно и контролировать возможность хода не требуется.
"""
class Checkers:
    def __init__(self):
        # Словарь для итерации по ключам и значениям (Например: A1: X, B1: B, C1: X, D1: B)
        # При этом неважно в каком порядке будут поступать строки и столбцы, что крайне важно.
        self.board = {}
        # Итерация по строкам от 1 до 8 включительно
        for row in range(1, 9):
            # Итерация по столбцам так же от 1 до 8 включительно, поле 8 на 8
            for col in 'ABCDEFGH':
                # Придание нужного вида: A1, B1, C1
                coordinates = col + str(row)
                # Условие, которое определяет выставление символа.
                # Я использую тут ord() для выявления разницы между символами A и BCDEFGH
                # Т.е. A = 65, B = 66, C = 67 и т.д.
                # Тем самым, если столбец четный - поставится символ X
                if (row + ord(col) - ord('A')) % 2 == 0:
                    self.board[coordinates] = Cell('X')
                # Если строка меньше или равна 3 по условиям задачи, выставляем W
                elif row <= 3:
                    self.board[coordinates] = Cell('W')
                # Так как 2 в центре не учитываем, то сразу после 6 строки включительно выставляем B
                elif row >= 6:
                    self.board[coordinates] = Cell('B')
                # Иначе X (т.е. заполняем центр символами X)
                else:
                    self.board[coordinates] = Cell('X')

    def move(self, f, t):
        # Меняем местами символы. Место X - символ. Место символа X
        self.board[t] = self.board[f]
        self.board[f] = Cell('X')

    def get_cell(self, p):
        # Возвращаем значение клетки, т.е. символ X, B или W
        return self.board[p]


class Cell:
    def __init__(self, status):
        # Инициализируем статус, в который передается символ
        self._status = status

    def status(self):
        # Возвращаем данный символ
        return self._status


checkers = Checkers()
for row in '87654321':
    for col in 'ABCDEFGH':
        print(checkers.get_cell(col + row).status(), end='')
    print()
